(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{108:function(t,a,s){"use strict";s.r(a);var e=s(0),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"网络传输层加速"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络传输层加速"}},[t._v("#")]),t._v(" 网络传输层加速")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("缓存一般分为强缓存和协商缓存，主要区别是：使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。")])]),t._v(" "),s("h2",{attrs:{id:"浏览器缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),s("h3",{attrs:{id:"强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),s("p",[t._v("主要通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制")]),t._v(" "),s("p",[t._v("一般，我们会设置 Cache-Control 的值为“public, max-age=xxx”，表示在 xxx 秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。")]),t._v(" "),s("h2",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),s("p",[t._v("每次都向服务器验证一下缓存的有效性")]),t._v(" "),s("h2",{attrs:{id:"前端缓存方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存方案"}},[t._v("#")]),t._v(" 前端缓存方案")]),t._v(" "),s("ul",[s("li",[t._v("HTML：使用协商缓存")]),t._v(" "),s("li",[t._v("CSS JS Image：使用强缓存，文件名带上 hash 值")])]),t._v(" "),s("p",[t._v("浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在 network 面板中各请求的 size 项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的 Etag 字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘中。")]),t._v(" "),s("h2",{attrs:{id:"资源打包压缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源打包压缩"}},[t._v("#")]),t._v(" 资源打包压缩")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率")])]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("gulp grunt webpack parcel\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h2",{attrs:{id:"图片资源优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图片资源优化"}},[t._v("#")]),t._v(" 图片资源优化")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[t._v("用过ngxin的人都知道,ngxin可以把文件设置为gzip压缩格式,但是图片不要设置gzip压缩!图片不要设置gzip压缩!图片不要设置gzip压缩!")])]),t._v(" "),s("ul",[s("li",[t._v("不要在 HTML 里缩放图像")]),t._v(" "),s("li",[t._v("使用雪碧图（CSS Sprite）- webpack-spritesmith")]),t._v(" "),s("li",[t._v("使用字体图标（iconfont）- icomoon")]),t._v(" "),s("li",[t._v("使用 WebP - 图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间")])]),t._v(" "),s("h2",{attrs:{id:"网络传输性能检测工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络传输性能检测工具"}},[t._v("#")]),t._v(" 网络传输性能检测工具")]),t._v(" "),s("p",[t._v("Page Speed | PageSpeed Insights")]),t._v(" "),s("h2",{attrs:{id:"使用-cdn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-cdn"}},[t._v("#")]),t._v(" 使用 CDN")]),t._v(" "),s("p",[t._v("再好的性能优化实例，也必须在CDN的支撑下才能到达极致。")]),t._v(" "),s("p",[t._v("如果我们在Linux下使用命令$ traceroute targetIp 或者在Windows下使用批处理 > tracert targetIp，都可以定位用户与目标计算机之间经过的所有路由器，不言而喻，用户和服务器之间距离越远，经过的路由器越多，延迟也就越高。使用CDN的目的之一便是解决这一问题")])])}),[],!1,null,null,null);a.default=r.exports}}]);